(include "./language.neut")

(include "./option.neut")

(include "./bool.neut")

(include "./identity.neut")

(include "./string.neut")

(include "./integer.neut")

(define-data list ((a tau))
  (nil)
  (cons (_ a) (_ (list a))))

(section list)

(define-macro new-internal (a vs)
  (if-meta (meta.is-nil vs)
    `(list.nil ,a)
    `(list.cons ,a ,(meta.node.head vs) ,(new-internal a (meta.node.tail vs)))))

(define-macro-variadic new (a vs)
  (new-internal a vs))

(define head
  ((a tau)
   (xs (list a)))
  (witness (option a)
    (list.case (option a) a xs
      (λ ()
        (option.none a))
      (λ (h _)
        (option.some a h)))))

(define length
  ((a tau)
   (xs (list a)))
  (witness i64
    (list.case i64 a xs
      (λ ()
        0)
      (λ (_ ys)
        (add-i64 1 (length a ys))))))

(define append
  ((a tau)
   (xs (list a))
   (ys (list a)))
  (witness (list a)
    (list.case (list a) a xs
      (λ ()
        ys)
      (λ (z zs)
        (cons * z (append * zs ys))))))

(define is-null
  ((a tau)
   (xs (list a)))
  (witness bool
    (list.case bool a xs
      (λ ()
        bool.true)
      (λ (_ _)
        bool.false))))

(define map
  ((a tau)
   (b tau)
   (f (hom a b))
   (xs (list a)))
  (witness (list b)
    (list.case (list b) a xs
      (λ ()
        (nil b))
      (λ (y acc)
        (cons b (f y) (map a b f acc))))))

; (define return
;   ((a tau)
;    (x a))
;   (witness (list a)
;     (list.cons * x (list.nil a))))

(define return
  ((a tau)
   (x a))
  (witness (list a)
    (list.new * x)))

(define concatenate
  ((a tau)
   (m (list (list a))))
  (witness (list a)
    (list.case (list a) (list a) m
      (λ ()
        (nil a))
      (λ (xs xss)
        (append * xs (concatenate * xss))))))

(define bind
  ((a tau)
   (b tau)
   (m (list a))
   (k (hom a (list b))))
  (witness (list b)
    (concatenate * (map * * k m))))

(end list)
