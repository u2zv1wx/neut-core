(include "./language.neut")

(include "./option.neut")

(include "./bool.neut")

(include "./noesis.neut")

(include "./noema.neut")

(define-data list ((a tau))
  (nil)
  (cons (_ a) (_ (list a))))

(section list)

(define-macro new-internal (a vs)
  (if-meta (meta.is-nil vs)
    `(list.nil ,a)
    `(list.cons ,a ,(meta.node.head vs) ,(new-internal a (meta.node.tail vs)))))

(define-macro-variadic new (a vs)
  (new-internal a vs))

(define head
  ((a tau)
   (xs (list a)))
  (witness (option a)
    (case xs
      ((nil)
        (option.none a))
      ((cons h _)
        (option.some a h)))))

(define length-internal
  ((s subject)
   (a tau)
   (xs (noema s (list a)))
   (acc i64))
  (witness i64
    (case-noetic xs
      ((list.nil)
        acc)
      ((list.cons _ ys)
        (length-internal s a ys (add-i64 acc 1))))))

(define length
  ((a tau)
   (xs (list a)))
  (witness (product (list a) i64)
    (with-region s
      (let xs-noema (noema.new s (list a) &xs))
      ((noesis.return s) * (tuple xs (length-internal s a xs-noema 0))))))

(define append
  ((a tau)
   (xs (list a))
   (ys (list a)))
  (witness (list a)
    (case xs
      ((nil)
        ys)
      ((cons z zs)
        (cons * z (append * zs ys))))))

(define is-null
  ((a tau)
   (xs (list a)))
  (witness bool
    (case xs
      ((nil)
        bool.true)
      ((cons _ _)
        bool.false))))

(define map
  ((a tau)
   (b tau)
   (f (hom a b))
   (xs (list a)))
  (witness (list b)
    (case xs
      ((nil)
        (nil b))
      ((cons y acc)
        (cons b (f y) (map a b f acc))))))

(define return
  ((a tau)
   (x a))
  (witness (list a)
    (list.new * x)))

(define concatenate
  ((a tau)
   (m (list (list a))))
  (witness (list a)
    (case m
      ((nil)
        (nil a))
      ((cons xs xss)
        (append * xs (concatenate * xss))))))

(define bind
  ((a tau)
   (b tau)
   (m (list a))
   (k (hom a (list b))))
  (witness (list b)
    (concatenate * (map * * k m))))

(end list)
