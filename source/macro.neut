(declare-enum bool
  (true 1)
  (false 0))

(define-macro init-meta (xs)
  (if-meta (is-nil (tail xs))
    `()
    (cons (head xs) (init-meta (tail xs)))))

(define-macro last-meta (xs)
  (if-meta (is-nil (tail xs))
    (head xs)
    (last-meta (tail xs))))

(define-macro map-meta (f xs)
  (if-meta (is-nil xs)
    xs
    (cons (f (head xs)) (map-meta f (tail xs)))))

(define-macro fst-map-meta (f x)
  `(,(f (nth 0 x)) ,(nth 1 x)))

(define-macro snd-map-meta (f x)
  `(,(nth 0 x) ,(f (nth 1 x))))

(define-macro compose-meta (f g)
  (lambda-meta (x) (f (g x))))

; (lambda-meta (x) `(,(var (nth 0 x)) ,(nth 1 x)))

(define-macro filter-meta (p xs)
  (if-meta (is-nil xs)
    xs
    (if-meta (p (head xs))
      (cons (head xs) (filter-meta p (tail xs)))
      (filter-meta p (tail xs)))))

(define-macro append-meta (xs ys)
  (if-meta (is-nil xs)
    ys
    (cons (head xs) (append-meta (tail xs) ys))))

(define-macro list-meta-internal (xss)
  (if-meta (is-nil xss)
    `()
    (append-meta (head xss) (list-meta-internal (tail xss)))))

(define-macro-variadic list-meta (xss)
  (list-meta-internal xss))

(define-macro var (x)
  (if-meta (leaf-equal `_ x)
    (new-symbol x)
    x))

;
; foundational macros
;

(define-macro tau `tau)

(define-macro * `*)

(define-macro Π (args body)
  `(Π ,args ,body))

(define-macro Π-introduction (args body)
  `(Π-introduction ,args ,body))

(define-macro-variadic Π-elimination (fun args)
  `(Π-elimination ,fun @,args))

(define-macro fix (self args body)
  `(fix ,self ,args ,body))

(define-macro-variadic enum-elimination (value clauses)
  `(enum-elimination ,value @,clauses))

(define-macro array (dom kind)
  `(array ,dom ,kind))

(define-macro-variadic array-introduction (kind values)
  `(array-introduction ,kind @,values))

(define-macro array-elimination (kind xts arr cont)
  `(array-elimination ,kind ,xts ,arr ,cont))

(define-macro-variadic struct (kinds)
  `(struct @,kinds))

; kes = ((kind-1 term-1) ... (kind-n term-n))
(define-macro-variadic struct-introduction (kes)
  `(struct-introduction @,kes))

(define-macro struct-elimination (xts e1 e2)
  `(struct-elimination ,xts ,e1 ,e2))

(define-macro question (e)
  `(question ,e))

;
; statements
;

(define-macro declare-constant (name t)
  `(declare-constant ,name ,t))

(define-macro-variadic declare-enum (rest)
  `(declare-enum @,rest))

(define-macro-variadic define (f rest)
  (if-meta (is-nil (tail rest))
    `(let ,f ,(head rest))
    (define f
      `(fix ,f ,(head rest) ,(head (tail rest))))))

(define-macro define-resource-type (name discarder copier)
  `(define-resource-type ,name ,discarder ,copier))

(define-macro-variadic statement (stmt-list)
  `(statement @,stmt-list))

;
; auxiliary macros
;

(define-macro type
  tau)

(define-macro universe
  type)

(define-macro forall
  Π)

(define-macro Pi
  Π)

(define-macro lambda
  Π-introduction)

(define-macro λ
  Π-introduction)

(define-macro witness (t e)
  (begin-meta
    (let sym (new-symbol `wit))
    `(,(λ `((,sym ,t)) sym) ,e)))

(define-macro hom-internal (ts)
  (if-meta (is-nil (tail ts))
    (head ts)
    (Π `((_ ,(head ts))) (hom-internal (tail ts)))))

(define-macro-variadic hom (ts)
  (hom-internal ts))

(define-macro theorem (x t e)
  `(let (,x ,t) ,e))

(define-macro assume
  Π-introduction)

(define-macro switch
  enum-elimination)

(define-macro if (cond on-true on-false)
  (switch cond
    `(1 ,on-true)
    `(default ,on-false)))

(define-macro sigma (xts t)
  (begin-meta
    (let sym (new-symbol `sig))
    (forall `((,sym ,tau)
              (_ ,(forall `(@,xts (_ ,t)) sym)))
             sym)))

(define-macro exists
  sigma)

(define-macro product-internal (ts)
  (begin-meta
    (let sym (new-symbol `prod))
    (Π `((,sym ,tau)
         (_ ,(Π (map-meta (lambda-meta (t) `(_ ,t)) ts) sym)))
        sym)))

(define-macro-variadic product (ts)
  (product-internal ts))

(define-macro sigma-introduction-internal (es)
  (begin-meta
    (let Z (new-symbol `sig))
    (let k (new-symbol `sig-k))
    (lambda
      `((,Z ,tau)
        (,k ,(Π (map-meta (lambda-meta (x) `(_ *)) es) Z)))
      `(,k @,es))))

(define-macro-variadic sigma-introduction (es)
  (sigma-introduction-internal es))

(define-macro sigma-elimination (xts e1 e2)
  `(,e1 * ,(lambda xts e2)))

(define-macro tuple
  sigma-introduction)

(define-macro construct
  sigma-introduction)

(define-macro and-meta (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.true
      bool.false)
    bool.false))

(define-macro or-meta (b1 b2)
  (if-meta b1
    bool.true
    (if-meta b2
      bool.true
      bool.false)))

(define-macro xor-meta (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.false
      bool.true)
    (if-meta b2
      bool.true
      bool.false)))

(define-macro not-meta (b)
  (if-meta b
    bool.false
    bool.true))


(define-macro identity-bind-meta (x k)
  (k x))

(define-macro is-borrowed-var-meta (x)
  (if-meta (is-node x)
    bool.false
    (leaf-equal `& (head (leaf-uncons x)))))

(define-macro take-borrowed-vars-meta (xs)
  (map-meta (lambda-meta (x) (nth 1 (leaf-uncons x))) (filter-meta is-borrowed-var-meta xs)))

(define-macro drop-char-meta (ch x)
  (if-meta (is-node x)
    x
    (begin-meta
      (let c-rest (leaf-uncons x))
      (if-meta (leaf-equal (nth 0 c-rest) ch)
        (nth 1 c-rest)
        x))))

(define-macro obtain-borrow-info-meta (xs)
  (if-meta (is-leaf xs)
    `(()
      ,xs)
    `(,(take-borrowed-vars-meta xs)
      ,(map-meta (lambda-meta (x) (drop-char-meta `& x)) xs))))

(define-macro with-internal (bind es)
  (if-meta (is-nil (tail es))
    (head es)
    (begin-meta
      (let e (head es))
      (let rest (tail es))
      (if-meta (is-leaf e)
        `(,bind * * ,e ,(λ `(_) (with-internal bind rest)))
        (if-meta (not-meta (leaf-equal (nth 0 e) `let))
          (with-internal bind (append-meta `((let _ ,e)) rest))
          (begin-meta
            (let var-name (nth 1 e))
            (let let-body (tail (tail e)))
            (let last-term (last-meta let-body))
            (let borrow-info (obtain-borrow-info-meta last-term))
            (let borrow-var-list (nth 0 borrow-info))
            (let var-list (append-meta borrow-var-list `(,var-name)))
            (let let-body' (append-meta (init-meta let-body) `(,(nth 1 borrow-info))))
            (let s (new-symbol `with-sig))
            (if-meta (is-nil borrow-var-list)
              `(,bind * * ,(with-internal bind let-body) ,(λ `(,var-name) (with-internal bind rest)))
              (with-internal bind
                `(,(append-meta `(let ,s) let-body')
                  ,(sigma-elimination var-list s (with-internal bind rest)))))))))))

(define-macro-variadic with (bind es)
  (with-internal bind es))

(define-macro-variadic destruct (e xts rest)
  (sigma-elimination xts e (with-internal `identity.bind rest)))

(define-macro-variadic reduce (es)
  (with-internal `identity.bind es))

(define-macro concat-meta-internal (args)
  (if-meta (is-nil (tail args))
    (head args)
    (leaf-mul (head args) (concat-meta-internal (tail args)))))

(define-macro-variadic concat-meta (args)
  (concat-meta-internal args))

(define-macro to-constructor (lam-args base-type a xts bt)
  (begin-meta
    (let constructor-name (concat-meta a `. (head bt)))
    (let bar (map-meta (fst-map-meta var _) (tail bt)))
    (let constructor-args `(@,xts @,bar))
    (let inductive-type `(,a @,(map-meta head xts)))
    (let args (map-meta head bar))
    (define constructor-name constructor-args
      (witness inductive-type
        `(unsafe.cast ,base-type ,inductive-type
          ,(lambda lam-args
            `(,(head bt) @,args)))))))

(define-macro-variadic define-data (a xts bts)
  (begin-meta
    (let Z (new-symbol `Z))
    (let inductive-type `(,a @,(map-meta head xts)))
    ; definition of type
    (let type-list (map-meta (lambda-meta (ts) `(,(head ts) ,(Pi (tail ts) Z))) bts))
    (let lam-args `((,Z tau) @,type-list))
    (let base-type (Pi lam-args Z))
    (let formation-rule
      (define a xts base-type))
    ; definition of constructors
    (let introduction-rule-list (map-meta (to-constructor lam-args base-type a xts _) bts))
    ; definition of destructors
    (let v (new-symbol `value))
    (let formal-args `(((unsafe.cast ,inductive-type ,base-type ,v) ,inductive-type) (,Z tau) @,type-list))
    (let elimination-rule
      (define (concat-meta a `.case) `((,Z tau) @,xts (,v ,inductive-type) @,type-list)
        (witness Z
          (map-meta head formal-args))))
    ; summing up the result
    `(statement
        ,formation-rule
        @,introduction-rule-list
        ,elimination-rule)))

(define-macro codata.generate-projection (name xts yts y result-type)
  (begin-meta
    (let form-args (map-meta head xts))
    (let app `(,name @,form-args))
    (let record-var (new-symbol `rec))
    (let base-args `(@,xts (,record-var ,app)))
    (let case (concat-meta name `.case))
    (let proj-type (forall base-args result-type))
    `(let (,(concat-meta name `. y) ,proj-type)
       ,(lambda base-args
          `(,case ,result-type @,form-args ,record-var ,(lambda yts y))))))

(define-macro-variadic define-codata (name xts yts)
  (begin-meta
    (let xs (map-meta head xts))
    (let proj-name-list (map-meta head yts))
    (let name-list (map-meta (concat-meta name `. _) proj-name-list))
    (let elimination-rule-list
      (map-meta (lambda-meta (yt) (codata.generate-projection name xts yts (nth 0 yt) (nth 1 yt))) yts))
    `(statement
       ,(define-data name xts
          `(new @,yts))
       @,elimination-rule-list)))
