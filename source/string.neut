(include "./foundation.neut")

(include "./identity.neut")

(include "./memory.neut")

(include "./array.neut")

(define-opaque string
  i8-array)

(define-macro string.new (str)
  `(unsafe.cast i8-array string ,(i8-array.new (meta.node.map (lambda-meta (x) `(i8 ,x)) (meta.leaf.string-to-i8-list str)))))

(define print-character ((value i8))
  (with identity.bind
    (let p (memory.allocate 1))
    (memory.store-i8-with-index value p 0)
    (let len (os.write os.stdout p 1))
    (memory.deallocate unsafe.pointer p)
    top.unit))

; (define print-character ((value i8))
;   (with identity.bind
;     (let p (memory.allocate 1))
;     (memory.store-i8-with-index value p 0)
;     (let len (os.write os.stdout &p 1))
;     (memory.deallocate unsafe.pointer p)
;     top.unit))

(define string.print ((str string))
  (witness (product string i64)
    (with identity.bind
      (let ptr (unsafe.cast string unsafe.pointer str))
      (let n (memory.load-i64 ptr))
      (let content (memory.load-pointer-with-index ptr 1))
      (let wrote-length (os.write os.stdout content n))
      (let str (unsafe.cast unsafe.pointer string ptr))
      (tuple str wrote-length)))) ; (tuple (unsafe.cast ...) wrote-length) とするとstr部分がunsafe.pointerとしてfreeされてしまうのでダメ。これは注意が必要なところ。

; (define string.print ((str string))
;   (witness (product string i64)
;     (with identity.bind
;       (let ptr (unsafe.cast string unsafe.pointer str))
;       (let n (memory.load-i64 ptr))
;       (let content (memory.load-pointer-with-index ptr 1))
;       (let wrote-length (os.write os.stdout &content n))
;       (let str (unsafe.cast unsafe.pointer string ptr))
;       (tuple str wrote-length)))) ; (tuple (unsafe.cast ...) wrote-length) とするとstr部分がunsafe.pointerとしてfreeされてしまうのでダメ。これは注意が必要なところ。

(define-macro string.print-literal (str)
  `(string.print ,(string.new str)))

(reduce
  ; (let ptr (memory.allocate 3))
  ; (memory.store-i8-with-index 10 &ptr 0)
  ; (memory.store-i8-with-index 20 &ptr 1)
  ; (memory.store-i8-with-index 30 &ptr 2)
  ; ; (let outer (tensor-introduction (i64 3) ptr))
  ; (let outer (memory.allocate 2))
  ; ; ; (memory.store-i64-with-index 2 &outer 0)
  ; (memory.store-i64-with-index 3 &outer 0)
  ; (memory.store-pointer-with-index ptr &outer 1)
  ; (let test (unsafe.cast * i8-array outer))
  ; (let _ test)
  ; (let _ test)
  ; (let _ test)


  (let test2 (i8-array-introduction (i8 10) (i8 20) (i8 30)))
  (let _ test2)
  (let _ test2)
  (let _ test2)

  (let hello (string.new "hello\n"))
  (let foo hello)
  (string.print &hello)
  (string.print &hello)
  (let bar (string.print hello)) ; この bar : product string top がうまく解放されない。なんで？
  (let _ hello)

; (memory.deallocate unsafe.pointer outer)
  ; (memory.deallocate unsafe.pointer ptr)
; (memory.deallocate unsafe.pointer ptr)
  ; (memory.deallocate unsafe.pointer outer)

; (let ptr (memory.allocate 1))
  ; (memory.store-i8 &ptr 10)
  ; (let outer (memory.allocate 1))
  ; ; (memory.store-i64-with-index 2 &outer 0)
  ; (memory.store-pointer &outer ptr)
  ; (memory.deallocate unsafe.pointer ptr)
  ; (memory.deallocate unsafe.pointer outer)
  ; (let test (unsafe.cast unsafe.pointer i8-array outer))
  ; (let test (i8-array-introduction (i8 10) (i8 20)))
  ; (let _ test)
  ; (let _ test)
  ; (let _ test)
  ; (let test (unsafe.cast * unsafe.pointer (i8-array-introduction (i8 10) (i8 20))))
  ; (let content (memory.load-pointer-with-index &test 1))
  ; (memory.deallocate unsafe.pointer test)
  ; (memory.deallocate unsafe.pointer content)
; (let _ test)
  ; (let _ test)
  ; (let _ test)
  ; (let str (string.new "hello"))
  ; (string.print &str)
  ; (string.print &str)
; (let foo str)
  ; (let foo str)
  ; (let foo str)
  ; (let foo str)
  ; (let foo str)
  ; (let foo str)
  ; (let foo str)
  top.unit)

; (reduce
;   (let str (string.new "hello\n"))
;   (let foo (lambda () str))
;   ; (let foo (fix-irreducible hoge () str))
;   (let bar (foo))
;   (let bar (foo))

; ; (let x (string.print &str))
;   top.unit)


; (reduce
;   (let str (string.new "hello"))
;   (let foo (fix-irreducible hoge () str))
;   (let bar (foo))
;   (let bar (foo))

; ; (let x (string.print &str))
;   top.unit)

; (define pohe
;   (with identity.bind
;     (let a (string.new "hello"))
;     (string.print a)
;     (string.print a)
;     (string.print a)
;     top.unit))

; (define my-type () tau)

; (define-macro my-type `(my-type))

; (define f (lambda ((a my-type)) a))

; ; (reduce ?f)

; (define test
;   pohe)

; (define main ()
;   test)

; (reduce
;   pohe
;   pohe
;   pohe)
