(declare-enum-meta top unit)

(declare-enum-meta bool true false)

(let-meta define-meta-function
  (lambda-meta (f args body)
    `(let-meta #f (fix-meta #f #args #body))))
(auto-quote define-meta-function)

(let-meta define-meta-function-variadic
  (lambda-meta (f args body)
    `(let-meta #f (fix-meta-variadic #f #args #body))))
(auto-quote define-meta-function-variadic)

(define-meta-function force (f)
  (f))

(define-meta-function if-meta (cond on-true on-false)
  (switch-meta (force cond)
    (bool.true (force on-true))
    (bool.false (force on-false))))
(auto-thunk if-meta)

(define-meta-function init (xs)
  (if-meta (is-nil (tail xs))
    `()
    (cons (head xs) (init (tail xs)))))

(define-meta-function last (xs)
  (if-meta (is-nil (tail xs))
    (head xs)
    (last (tail xs))))

(define-meta-function map (f xs)
  (if-meta (is-nil xs)
    xs
    (cons (f (head xs)) (map f (tail xs)))))

(define-meta-function filter (p xs)
  (if-meta (is-nil xs)
    xs
    (if-meta (p (head xs))
      (cons (head xs) (filter p (tail xs)))
      (filter p (tail xs)))))

(define-meta-function append (xs ys)
  (if-meta (is-nil xs)
    ys
    (cons (head xs) (append (tail xs) ys))))

(define-meta-function define-macro-internal (f body)
  `(statement-meta
     (let-meta #f #body)
     (auto-quote #f)))

(define-meta-function-variadic define-macro (f rest)
  (if-meta (is-nil (tail rest))
    (define-macro-internal f
      (head rest))
    (define-macro f
      `(fix-meta #f #(head rest) #(head (tail rest))))))
(auto-quote define-macro)

(define-meta-function define-macro-variadic (f args body)
  (define-macro-internal f
    `(fix-meta-variadic #f #args #body)))
(auto-quote define-macro-variadic)

;
; foundational macros
;

(define-macro tau `tau)

(define-macro * `*)

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro Π (args body)
  `(Π #args #body))

(define-macro Π-introduction (args body)
  `(Π-introduction #args #body))

(define-macro-variadic Π-elimination (fun args)
  (append `(Π-elimination #fun) args))

; ; fixme: 対象言語と「fix」が名前で被っているのをどうにかする。でないとauto-quoteが誤爆する。
(define-macro fix (self args body)
  `(fix #self #args #body))

(define-macro as-f16 (x)
  `(f16 #x))

(define-macro as-f32 (x)
  `(f32 #x))

(define-macro as-f64 (x)
  `(f64 #x))

(define-macro-variadic enum-elimination (value clauses)
  (append `(enum-elimination #value) clauses))

(define-macro array (dom kind)
  `(array #dom #kind))

(define-macro-variadic array-introduction (kind values)
  (append `(array-introduction #kind) values))

(define-macro array-elimination (kind xts arr cont)
  `(array-elimination #kind #xts #arr #cont))

(define-macro-variadic struct (kinds)
  (append `(struct) kinds))

; kes = ((kind-1 term-1) ... (kind-n term-n))
(define-macro-variadic struct-introduction (kes)
  (append `(struct-introduction) kes))

(define-macro struct-elimination (xts e1 e2)
  `(struct-elimination #xts #e1 #e2))

(define-macro question (e)
  `(question #e))

(define-macro erase (mxs body)
  `(erase #mxs #body))

(define-macro irreducible (e)
  `(irreducible #e))

; (define-macro-variadic with (rest)
;   (append `(with) rest))

;
; statements
;

(define-macro constant (name t)
  `(constant #name #t))

(define-macro-variadic declare-enum (rest)
  (append `(declare-enum) rest))

(define-macro end (arg)
  `(end #arg))

; (define-macro data (name xts rest)
;   `(data #name #xts #rest))

(define-macro-variadic data (rest)
  (append `(data) rest))

; (define-macro-variadic data (rest)
;   (if-meta (is-nil rest)
;     `(data)
;     (if-meta (is-leaf (head rest))
;       (append `(data #(head rest) #(head (tail rest))) (tail (tail rest)))
;       (append `))))

; (define-macro let (name e)
;   `(let #name #e))

(define-macro-variadic define (f rest)
  (if-meta (is-nil (tail rest))
    `(let #f #(head rest))
    (define f
      `(fix #f #(head rest) #(head (tail rest))))))

(define-macro-variadic record (name xts rest)
  (append `(record #name #xts) rest))

(define-macro section (arg)
  `(section #arg))

(define-macro use (arg)
  `(use #arg))

(define-macro unuse (arg)
  `(unuse #arg))

;
; auxiliary macros
;

(define-macro type
  `tau)

(define-macro universe
  `type)

(define-macro forall
  `Π)

(define-macro Pi
  `Π)

(define-macro lambda
  `Π-introduction)

(define-macro λ
  `Π-introduction)

(define-macro witness (t e)
  `(#(λ `((x #t)) `x) #e))

(define-meta-function hom-internal (ts)
  (if-meta (is-nil (tail ts))
    (head ts)
    (Π `((_ #(head ts))) (hom-internal (tail ts)))))

(define-macro-variadic hom (ts)
  (hom-internal ts))

(define-macro theorem (x t e)
  `(let (#x #t) #e))

(define-macro assume
  `Π-introduction)

(define-macro switch
  `enum-elimination)

(define-macro if (cond on-true on-false)
  `(switch #cond
     (bool.true #on-true)
     (bool.false #on-false)))

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro sigma (xts t)
  `(forall ((sigma-internal.Z tau)
            (_ (forall #(append xts `((_ #t))) sigma-internal.Z)))
           sigma-internal.Z))


(define-macro exists
  `sigma)

(define-meta-function product-internal (ts)
  `(Π ((sigma-internal.Z tau)
       (_ (Π #(map (lambda-meta (t) `(_ #t)) ts) sigma-internal.Z)))
      sigma-internal.Z))

(define-macro-variadic product (ts)
  (product-internal ts))

(define-meta-function sigma-introduction-internal (es)
  `(lambda
     ((internal.Z tau)
      (internal.k (Π #(map (lambda-meta (x) `(_ *)) es) internal.Z)))
     #(append `(internal.k) es)))

(define-macro-variadic sigma-introduction (es)
  (sigma-introduction-internal es))

(define-macro sigma-elimination (xts e1 e2)
  `(#e1 * (lambda #xts #e2)))

(define-macro tuple
  `sigma-introduction)

(define-macro construct
  `sigma-introduction)

(define-meta-function and (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.true
      bool.false)
    bool.false))

(define-meta-function or (b1 b2)
  (if-meta b1
    bool.true
    (if-meta b2
      bool.true
      bool.false)))

(define-meta-function xor (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.false
      bool.true)
    (if-meta b2
      bool.true
      bool.false)))

(define-meta-function not (b)
  (if-meta b
    bool.false
    bool.true))

(define-meta-function identity-bind (x k)
  (k x))

(define-meta-function is-borrowed-var (x)
  (if-meta (is-node x)
    bool.false
    (leaf-equal `& (head (leaf-uncons x)))))

(define-meta-function take-borrowed-vars (xs)
  (map (lambda-meta (x) (nth 1 (leaf-uncons x))) (filter is-borrowed-var xs)))

(define-meta-function drop-char (ch x)
  (if-meta (is-node x)
    x
    (begin-meta
      (let c-rest (leaf-uncons x))
      (if-meta (leaf-equal (nth 0 c-rest) ch)
        (nth 1 c-rest)
        x))))

(define-meta-function obtain-borrow-info (xs)
  (if-meta (is-leaf xs)
    `(()
      #xs)
    `(#(take-borrowed-vars xs)
      #(map (lambda-meta (x) (drop-char `& x)) xs))))

; fixme: eraseも処理できるようにしましょう
; fixme: condで書き直したほうがわかりやすい。condをコンパイラ内部で定義するとよい？
(define-meta-function with-internal (bind es)
  (if-meta (is-nil (tail es))
    (head es)
    (begin-meta
      (let e (head es))
      (let rest (tail es))
      (if-meta (is-leaf e)
        `(#bind * * #e (λ (_) #(with-internal bind rest)))
        (if-meta (leaf-equal (nth 0 e) `let)
          (begin-meta
            (let var-name (nth 1 e))
            (let let-body (tail (tail e)))
            (let last-term (last let-body))
            (let borrow-info (obtain-borrow-info last-term))
            (let borrow-var-list (nth 0 borrow-info))
            (let var-list (append borrow-var-list `(#var-name)))
            (let let-body' (append (init let-body) `(#(nth 1 borrow-info))))
            (let s (new-symbol))
            ; (dump borrow-var-list)
            ; (dump var-list)
            ; (dump let-body')
            ; (dump (with-internal bind rest))
            (if-meta (is-nil borrow-var-list)
              `(#bind * * #(with-internal bind let-body) (λ (#var-name) #(with-internal bind rest)))
              (with-internal bind
                `(#(append `(let #s) let-body')
                  ;(let #s #let-body')
                  (sigma-elimination #var-list #s #(with-internal bind rest))))))
          `(#bind * * #e (λ (_) #(with-internal bind rest))))))))

(define-macro-variadic with (bind es)
  (with-internal bind es))

(define-macro-variadic destruct (e xts rest)
  `(sigma-elimination #xts #e #(with-internal `identity.bind rest)))

(define-macro-variadic reduce (es)
  (with-internal `identity.bind es))
