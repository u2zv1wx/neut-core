(enum top unit)

(enum bool true false)

(let define-meta-function
  (lambda (f args body)
    `(let #f (fix #f #args #body))))

(auto-quote define-meta-function)

(let define-meta-function+
  (lambda (f args body)
    `(let #f (fix+ #f #args #body))))

(auto-quote define-meta-function+)

(define-meta-function force (f)
  (f))

(define-meta-function if (cond on-true on-false)
  (switch (force cond)
     (bool.true (force on-true))
     (bool.false (force on-false))))

(auto-thunk if)

(define-meta-function map (f xs)
  (if (is-nil xs)
     xs
     (cons (f (head xs)) (map f (tail xs)))))

(define-meta-function append (xs ys)
  (if (is-nil xs)
     ys
     (cons (head xs) (append (tail xs) ys))))

(define-meta-function define-macro-internal (f body)
  `(statement
     (let #f #body)
     (auto-quote #f)))

(define-meta-function+ define-macro (f rest)
  (if (is-nil (tail rest))
    (define-macro-internal f
      (head rest))
    (define-macro f
      `(fix #f #(head rest) #(head (tail rest))))))

(auto-quote define-macro)

(define-meta-function define-macro+ (f args body)
  (define-macro-internal f
    `(fix+ #f #args #body)))

(auto-quote define-macro+)

;
; foundational macros
;

(define-macro tau `tau)

(define-macro * `*)

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro Π (args body)
  `(Π #args #body))

(define-macro Π-introduction (args body)
  `(Π-introduction #args #body))

(define-macro+ Π-elimination (fun args)
  (append `(Π-elimination #fun) args))

; ; fixme: 対象言語と「fix」が名前で被っているのをどうにかする。
(define-macro fix-low (self args body)
  `(fix #self #args #body))

; ; (fix-low foo bar buz)

(define-macro f16 (x)
  `(f16 #x))

(define-macro f32 (x)
  `(f32 #x))

(define-macro f64 (x)
  `(f64 #x))

(define-macro+ enum-elimination (value clauses)
  (append `(enum-elimination #value) clauses))

(define-macro array (dom kind)
  `(array #dom #kind))

(define-macro+ array-introduction (kind values)
  (append `(array-introduction #kind) values))

(define-macro array-elimination (kind xts arr cont)
  `(array-elimination #kind #xts #arr #cont))

(define-macro+ struct (kinds)
  (append `(struct) kinds))

; kes = ((kind-1 term-1) ... (kind-n term-n))
(define-macro+ struct-introduction (kes)
  (append `(struct-introduction) kes))

(define-macro struct-elimination (xts e1 e2)
  `(struct-elimination #xts #e1 #e2))

(define-macro question (e)
  `(question #e))

(define-macro erase (mxs body)
  `(erase #mxs #body))

(define-macro irreducible (e)
  `(irreducible #e))

(define-macro+ with (rest)
  (append `(with) rest))

;
; statements
;

(define-macro constant (name t)
  `(constant #name #t))

(define-macro end (arg)
  `(end #arg))

; (define-macro data (name xts rest)
;   `(data #name #xts #rest))

; (define-macro let (name t e)
;   `(let-low #name #t #e))


; このときはletに対してaqをおこなってしまう。よくない？
; (let x `tau)

; x

(define-macro+ record (name xts rest)
  `(record #name #xts #rest))

(define-macro section (arg)
  `(section #arg))

(define-macro use (arg)
  `(use #arg))

(define-macro unuse (arg)
  `(unuse #arg))

;
; auxiliary macros
;

(define-macro type
  tau)

(define-macro universe
  tau)

(define-macro forall
  Π)

(define-macro Pi
  Π)

; fixme: switchでの名前の衝突
; (notation switch
;   enum-elimination)

; fixme: lambdaでの名前の衝突
; (notation lambda
;   Π-introduction)

(define-macro λ
  Π-introduction)

(define-macro witness (t e)
  `(#(λ `((x #t)) `x) #e))

(define-meta-function hom-internal (ts)
  (if (is-nil (tail ts))
     (head ts)
     (Π `((_ #(head ts))) (hom-internal (tail ts)))))

(define-macro+ hom (ts)
  (hom-internal ts))

(define-macro theorem (x t e)
  `(let-low (#x #t) #e))

(define-macro assume
  Π-introduction)

(define-macro if-obj (cond on-true on-false)
  `(switch #cond
      (bool.true #on-true)
      (bool.false #on-false)))

(define-macro+ define (f rest)
  (if (is-nil (tail rest))
     `(literal (let #f #(head rest)))
     (define f
       `(fix #f #(head rest) #(head (tail rest))))))

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro sigma (xts t)
  `(forall ((Z tau)
            (_ (forall #(append xts `((_ #t))) Z)))
           Z))

(define-macro exists
  `sigma)

(define-meta-function product-internal (ts)
  `(Π ((Z tau)
       (_ (Π #(map (lambda (t) `(_ #t)) ts) Z)))
      Z))

(define-macro+ product (ts)
  (product-internal ts))

(define-meta-function sigma-introduction-internal (es)
  `(lambda
     ((internal.Z tau)
      (internal.k (Π #(map (lambda (x) `(_ *)) es) internal.Z)))
     #(append `(internal.k) es)))

(define-macro+ sigma-introduction (es)
  (sigma-introduction-internal es))

(define-macro sigma-elimination (xts e1 e2)
  `(#e1 * (lambda #xts #e2)))

(sigma-elimination (x1 x2 x3) bar buz)

(define-macro tuple
  `sigma-introduction)

(define-macro construct
  `sigma-introduction)

(define-macro+ destruct (e xts rest)
  `(sigma-elimination #xts #e #(append `(with identity.bind) rest)))

; (define fact (x)
;   (witness i64
;     (if-obj (int-le x 0)
;       1
;       (int-mul x (fact (int-sub x (if-obj a b c)))))))
; これでよくね〜？
