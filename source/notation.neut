(declare-enum-meta top unit)

(declare-enum-meta bool true false)

(define-meta force (f)
  (f))

(define-meta if-meta (cond on-true on-false)
  (switch-meta (force cond)
    (bool.true (force on-true))
    (bool.false (force on-false))))
(auto-thunk if-meta)

(define-meta init (xs)
  (if-meta (is-nil (tail xs))
    `()
    (cons (head xs) (init (tail xs)))))

(define-meta last (xs)
  (if-meta (is-nil (tail xs))
    (head xs)
    (last (tail xs))))

(define-meta map (f xs)
  (if-meta (is-nil xs)
    xs
    (cons (f (head xs)) (map f (tail xs)))))

(define-meta filter (p xs)
  (if-meta (is-nil xs)
    xs
    (if-meta (p (head xs))
      (cons (head xs) (filter p (tail xs)))
      (filter p (tail xs)))))

(define-meta append (xs ys)
  (if-meta (is-nil xs)
    ys
    (cons (head xs) (append (tail xs) ys))))

;
; foundational macros
;

(define-macro tau `tau)

(define-macro * `*)

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro Π (args body)
  `(Π #args #body))

(define-macro Π-introduction (args body)
  `(Π-introduction #args #body))

(define-macro-variadic Π-elimination (fun args)
  (append `(Π-elimination #fun) args))

(define-macro fix (self args body)
  `(fix #self #args #body))

(define-macro-variadic enum-elimination (value clauses)
  (append `(enum-elimination #value) clauses))

(define-macro array (dom kind)
  `(array #dom #kind))

(define-macro-variadic array-introduction (kind values)
  (append `(array-introduction #kind) values))

(define-macro array-elimination (kind xts arr cont)
  `(array-elimination #kind #xts #arr #cont))

(define-macro-variadic struct (kinds)
  (append `(struct) kinds))

; kes = ((kind-1 term-1) ... (kind-n term-n))
(define-macro-variadic struct-introduction (kes)
  (append `(struct-introduction) kes))

(define-macro struct-elimination (xts e1 e2)
  `(struct-elimination #xts #e1 #e2))

(define-macro question (e)
  `(question #e))

; (define-macro erase (mxs body)
;   `(erase #mxs #body))

(define-macro irreducible (e)
  `(irreducible #e))

;
; statements
;

(define-macro declare-constant (name t)
  `(declare-constant #name #t))

(define-macro-variadic declare-enum (rest)
  (append `(declare-enum) rest))

(define-macro end (arg)
  `(end #arg))

; (define-macro data (name xts rest)
;   `(data #name #xts #rest))

(define-macro-variadic data (rest)
  (append `(data) rest))

(define-macro-variadic define (f rest)
  (if-meta (is-nil (tail rest))
    `(let #f #(head rest))
    (define f
      `(fix #f #(head rest) #(head (tail rest))))))

(define-macro-variadic record (name xts rest)
  (append `(record #name #xts) rest))

(define-macro section (arg)
  `(section #arg))

(define-macro use (arg)
  `(use #arg))

(define-macro unuse (arg)
  `(unuse #arg))

;
; auxiliary macros
;

(define-macro type
  tau)

(define-macro universe
  type)

(define-macro forall
  Π)

(define-macro Pi
  Π)

(define-macro lambda
  Π-introduction)

(define-macro λ
  Π-introduction)

(define-macro witness (t e)
  (begin-meta
    (let sym (new-symbol))
    `(#(λ `((#sym #t)) sym) #e)))

(define-meta hom-internal (ts)
  (if-meta (is-nil (tail ts))
    (head ts)
    (Π `((_ #(head ts))) (hom-internal (tail ts)))))

(define-macro-variadic hom (ts)
  (hom-internal ts))

(define-macro theorem (x t e)
  `(let (#x #t) #e))

(define-macro assume
  Π-introduction)

(define-macro switch
  enum-elimination)

(define-macro if (cond on-true on-false)
  (switch cond
    `(bool.true #on-true)
    `(bool.false #on-false)))

(define-macro sigma (xts t)
  (begin-meta
    (let sym (new-symbol))
    (forall `((#sym #tau)
              (_ #(forall (append xts `((_ #t))) sym)))
             sym)))

(define-macro exists
  sigma)

(define-meta product-internal (ts)
  (begin-meta
    (let sym (new-symbol))
    (Π `((#sym #tau)
         (_ #(Π (map (lambda-meta (t) `(_ #t)) ts) sym)))
        sym)))

(define-macro-variadic product (ts)
  (product-internal ts))

(define-meta sigma-introduction-internal (es)
  (begin-meta
    (let Z (new-symbol))
    (let k (new-symbol))
    (lambda
      `((#Z #tau)
        (#k #(Π (map (lambda-meta (x) `(_ *)) es) Z)))
      (append `(#k) es))))

(define-macro-variadic sigma-introduction (es)
  (sigma-introduction-internal es))

(define-macro sigma-elimination (xts e1 e2)
  `(#e1 * #(lambda xts e2)))

(define-macro tuple
  sigma-introduction)

(define-macro construct
  sigma-introduction)

(define-meta and (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.true
      bool.false)
    bool.false))

(define-meta or (b1 b2)
  (if-meta b1
    bool.true
    (if-meta b2
      bool.true
      bool.false)))

(define-meta xor (b1 b2)
  (if-meta b1
    (if-meta b2
      bool.false
      bool.true)
    (if-meta b2
      bool.true
      bool.false)))

(define-meta not (b)
  (if-meta b
    bool.false
    bool.true))

(define-meta identity-bind (x k)
  (k x))

(define-meta is-borrowed-var (x)
  (if-meta (is-node x)
    bool.false
    (leaf-equal `& (head (leaf-uncons x)))))

(define-meta take-borrowed-vars (xs)
  (map (lambda-meta (x) (nth 1 (leaf-uncons x))) (filter is-borrowed-var xs)))

(define-meta drop-char (ch x)
  (if-meta (is-node x)
    x
    (begin-meta
      (let c-rest (leaf-uncons x))
      (if-meta (leaf-equal (nth 0 c-rest) ch)
        (nth 1 c-rest)
        x))))

(define-meta obtain-borrow-info (xs)
  (if-meta (is-leaf xs)
    `(()
      #xs)
    `(#(take-borrowed-vars xs)
      #(map (lambda-meta (x) (drop-char `& x)) xs))))

; fixme: condで書き直したほうがわかりやすい。condをコンパイラ内部で定義するとよい？
(define-meta with-internal (bind es)
  (if-meta (is-nil (tail es))
    (head es)
    (begin-meta
      (let e (head es))
      (let rest (tail es))
      (if-meta (is-leaf e)
        `(#bind * * #e #(λ `(_) (with-internal bind rest)))
        (if-meta (leaf-equal (nth 0 e) `erase)
          (begin-meta
            (let erased-vars (tail e))
            `(erase #erased-vars #(with-internal bind rest)))
          (if-meta (not (leaf-equal (nth 0 e) `let))
            (with-internal bind (append `((let _ #e)) rest))
            (begin-meta
              (let var-name (nth 1 e))
              (let let-body (tail (tail e)))
              (let last-term (last let-body))
              (let borrow-info (obtain-borrow-info last-term))
              (let borrow-var-list (nth 0 borrow-info))
              (let var-list (append borrow-var-list `(#var-name)))
              (let let-body' (append (init let-body) `(#(nth 1 borrow-info))))
              (let s (new-symbol))
              (if-meta (is-nil borrow-var-list)
                `(#bind * * #(with-internal bind let-body) #(λ `(#var-name) (with-internal bind rest)))
                (with-internal bind
                  `(#(append `(let #s) let-body')
                    #(sigma-elimination var-list s (with-internal bind rest))))))))))))

(define-macro-variadic with (bind es)
  (with-internal bind es))

(define-macro-variadic destruct (e xts rest)
  (sigma-elimination xts e (with-internal `identity.bind rest)))

(define-macro-variadic reduce (es)
  (with-internal `identity.bind es))
