(enum top unit)

(enum bool true false)

(let define-meta-function
  (lambda (f args body)
    `(let #f (fix #f #args #body))))

(auto-quote define-meta-function)

(let define-meta-function+
  (lambda (f args body)
    `(let #f (fix+ #f #args #body))))

(auto-quote define-meta-function+)

(define-meta-function if (cond on-true on-false)
  (switch cond
    (bool.true ,on-true)
    (bool.false ,on-false)))

(define-meta-function map (f xs)
  (if (is-nil xs)
    'xs
    '(cons (f (head xs)) (map f (tail xs)))))

(define-meta-function append (xs ys)
  (if (is-nil xs)
    'ys
    '(cons (head xs) (append (tail xs) ys))))

(define-meta-function define-macro-internal (f body)
  `(statement
     (let #f #body)
     (auto-quote #f)))

(define-meta-function+ define-macro (f rest)
  (if (is-nil (tail rest))
    '(define-macro-internal f
       (head rest))
    '(define-macro f
       `(fix #f #(head rest) #(head (tail rest))))))

(auto-quote define-macro)

(define-meta-function define-macro+ (f args body)
  (define-macro-internal f
    `(fix+ #f #args #body)))

(auto-quote define-macro+)

;
; foundational macros
;

(define-macro tau `tau)

(define-macro * `*)

; fixme: int, floatを対象言語に落とす方法を考える。たぶんleaf/nodeの一種として読むようにしてやればいいけど。
; （というかメタ言語にint/floatっているか？リストについての再帰でよくね）

(define-macro Π (args body)
  `(Π #args #body))

; (define-macro Π-introduction (args body)
;   `(Π-introduction #args #body))

; こっちが正解だった〜。はい。
; シンボルはシンボル自身に解決させましょうね。
(define-macro Π-introduction
  `Π-introduction)

(define-macro+ Π-elimination (fun args)
  (append `(Π-elimination #fun) args))

; fixme: 対象言語と「fix」が名前で被っているのをどうにかする。
(define-macro fix-low (self args body)
  `(fix #self #args #body))

; (fix-low foo bar buz)

(define-macro f16 (x)
  `(f16 #x))

(define-macro f32 (x)
  `(f32 #x))

(define-macro f64 (x)
  `(f64 #x))

; enum-introって構文としているう？
(define-macro+ enum-elimination (value clauses)
  (append `(enum-elimination #value) clauses))

(define-macro array (dom kind)
  `(array #dom #kind))

(define-macro+ array-introduction (kind values)
  (append `(array-introduction #kind) values))

(define-macro array-elimination (kind xts arr cont)
  `(array-elimination #kind #xts #arr #cont))

(define-macro+ struct (kinds)
  (append `(struct) kinds))

; kes = ((kind-1 term-1) ... (kind-n term-n))
(define-macro+ struct-introduction (kes)
  (append `(struct-introduction) kes))

(define-macro struct-elimination (xts e1 e2)
  `(struct-elimination #xts #e1 #e2))

(define-macro question (e)
  `(question #e))

(define-macro erase (mxs body)
  `(erase #mxs #body))

(define-macro irreducible (e)
  `(irreducible #e))

(define-macro+ with (rest)
  (append `(with) rest))

;
; auxiliary macros
;

; (Π-elimination (Π-introduction ((x1 A1) (x2 A2)) FUN_BODY) arg-1 (some-computation aaa))

; tauはすでに定義してあるのでこう書ける
(define-macro type
  tau)

(define-macro universe
  tau)

(define-macro forall
  Π)

(define-macro Pi
  Π)

; fixme: switchでの名前の衝突
; (notation switch
;   enum-elimination)

; fixme: lambdaでの名前の衝突
; (notation lambda
;   Π-introduction)

(define-macro λ
  Π-introduction)

; (λ foo bar)

(define-macro witness (t e)
  `((#λ ((x #t)) x) #e))

(define-meta-function hom-internal (ts)
  (if (is-nil (tail ts))
    '(head ts)
    '`(Π ((_ #(head ts))) #(hom-internal (tail ts)))))

(define-macro+ hom (ts)
  (hom-internal ts))

(define-macro theorem (x t e)
  `(literal (let (#x #t) #e)))

(define-macro assume
  Π-introduction)

; (notation (if b e1 e2)
;   (switch b
;     (bool.true
;       e1)
;     (bool.false
;       e2)))

(define-meta-function+ define (f rest)
  (if (is-nil (tail rest))
    '`(literal (let #f #(head rest)))
    '(define f
       `(fix #f #(head rest) #(head (tail rest))))))

; こうやってunquoteを明示的に入れてやればwitness部分は展開できるが。
; これの問題は、マクロを展開したい場所ではunquoteを外さないといけないってところ。
; まあ、witnessは、対象言語の関数として実装すればそれでいいという話はあるが。
; ただ、そうはいっても、たとえばdefineの中でbeginをつかうようなコードがあるとして、そこが展開されないってのは寒いでしょ。
; evaluateか〜？

(define-macro sigma (xts t)
  `(Π ((Z tau)
       (_ (Π #(append xts `((_ #t))) Z)))
      Z))

(auto-quote Σ)

; productも綺麗に書けた。メタ言語でのmapがうまく刺さった。

(define-meta-function product-internal (ts)
  `(Π ((Z tau)
       (_ (Π #(map (lambda (t) `(_ #t)) ts) Z)))
      Z))

(define-macro+ product (ts)
  (product-internal ts))

(define-meta-function sigma-introduction-internal (es)
  `(lambda
     ((internal.Z tau)
      (internal.k (Π #(map (lambda (x) `(_ *)) es) internal.Z)))
     #(append `(internal.k) es)))

(define-macro+ sigma-introduction (es)
  (sigma-introduction-internal es))

(define-meta-function sigma-elimination (xts e1 e2)
  `(#e1 * (lambda #xts #e2)))

(let tuple
  sigma-introduction)

(let construct
  sigma-introduction)

(define-macro+ destruct (e xts rest)
  (sigma-elimination xts e (append `(with identity.bind) rest)))

; ; ……というかさ。
; ; 対象言語でたとえば
; ; (define some-function (x) ...)
; ; みたいなものを定義したとするじゃん。で、これを
; ; (some-function foo)
; ; みたいに書いたとき、でも、実際には、これはメタ言語のものとして読まれてしまうよね？
; ; それって問題では？
; ; ……まあ、毎回letをするようにしていればいいのか。
; ; 必要ならば、同じことは(let _ foo)でもできるわけであって。
; ; (execute ...) みたいなstatementを作ればいいだけではある。
; ; (main ...)とかでもいい。
; ; あるいは、まあ、束縛されてないのが先頭に来ていたらtreeとして流す、とかでも。

; (define-macro execute (binder e)
;   `(let-internal _ (with #binder #e)))

; ; こういう感じの。
; (execute identity.bind
;   (print "foo"))
